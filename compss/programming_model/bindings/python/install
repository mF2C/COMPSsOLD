#!/bin/bash

  #
  # HELPER FUNCTIONS
  #

  clean() {
    rm -rf "${SCRIPT_DIR}"/build
  }

  command_exists () {
    type "$1" &> /dev/null ;
  }

  get_packages_folder(){
     # Check the packages folder of a particular python interpreter
     # $1 -> python version (2 or 3)
     packages_folder=$( $1 -c "import site
if hasattr(site, 'getsitepackages'):
    # normal execution
    print(site.getsitepackages()[0])
else:
    # workaround for virtualenv
    from distutils.sysconfig import get_python_lib
    print([get_python_lib()][0])
" )
  }

  install_for_py2 () {
    echo "Installing in ${targetDir}"
    PYCOMPSS_HOME="${targetDir}/2"
    export PYTHONPATH=$PYCOMPSS_HOME:$PYTHONPATH

    if command_exists python2 ; then
      python2 ${SCRIPT_DIR}/setup.py install --install-lib=${PYCOMPSS_HOME} -O2
      exitCode=$?
      if [ "$create_symlinks" = "true" ]; then
        get_packages_folder python2
        # Check if exists. If not, create.
        # mkdir -p ${packages_folder}      # Not necessary in sudo
        # Setup a symbolic link to pycompss
        ln -sfn "${PYCOMPSS_HOME}/pycompss" "${packages_folder}/pycompss"
        echo "Created symbolic link from ${PYCOMPSS_HOME}/pycompss to ${packages_folder}/pycompss"
        ln -sfn "${PYCOMPSS_HOME}/compss.so" "${packages_folder}/compss.so"
        echo "Created symbolic link from ${PYCOMPSS_HOME}/compss.so to ${packages_folder}/compss.so"
        ln -sfn "${PYCOMPSS_HOME}/thread_affinity.so" "${packages_folder}/thread_affinity.so"
        echo "Created symbolic link from ${PYCOMPSS_HOME}/thread_affinity.so to ${packages_folder}/thread_affinity.so"
      fi
      if [ $exitCode -ne 0 ]; then
        echo "ERROR: Cannot install PyCOMPSs for Python 2"
        exit $exitCode
      fi
    else
      echo "WARNING: PyCOMPSS FOR PYTHON 2 HAS NOT BEEN INSTALLED."
    fi
  }

  install_for_py3 () {
    PYCOMPSS_HOME="${targetDir}/3"
    # The previous line defines that the installation will be done in a different file from the previous
    # installation, and relies on the creation of a symbolic link from the interpreter library folder.
    # It is possible to install Python3 version within the same folder (python code is compatible), but:
    #   - The extensions have different names, so that the most appropriate can be selected dynamically.
    #   - pyc and pyo files are in different folders (for python2 within the same as .py files, while
    #     in python 3 they are within __pycache__ folder).
    export PYTHONPATH=$PYCOMPSS_HOME:$OLD_PYTHONPATH

    if command_exists python3 ; then
      python3 ${SCRIPT_DIR}/setup.py install --install-lib=${PYCOMPSS_HOME} -O2
      exitCode=$?
      if [ "$create_symlinks" = "true" ]; then
        get_packages_folder python3
        # Check if exists. If not, create.
        # mkdir -p ${packages_folder}      # Not necessary in sudo
        # Setup a symbolic link to pycompss
        ln -sfn "${PYCOMPSS_HOME}/pycompss" "${packages_folder}/pycompss"
        echo "Created symbolic link from ${PYCOMPSS_HOME}/pycompss to ${packages_folder}/pycompss"
        ln -sfn "${PYCOMPSS_HOME}/compss.*" "${packages_folder}/"
        echo "Created symbolic link from ${PYCOMPSS_HOME}/compss.* to ${packages_folder}/compss.*"
        ln -sfn "${PYCOMPSS_HOME}/thread_affinity.*" "${packages_folder}/"
        echo "Created symbolic link from ${PYCOMPSS_HOME}/thread_affinity.* to ${packages_folder}/thread_affinity.*"
      fi
      if [ $exitCode -ne 0 ]; then
        echo "ERROR: Cannot install PyCOMPSs for Python 3"
        exit $exitCode
      fi
    else
      echo "WARNING: PyCOMPSS FOR PYTHON 3 HAS NOT BEEN INSTALLED."
    fi
  }

  #
  # SCRIPT GLOBAL CONSTANTS
  #

  SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

  #
  # MAIN
  #

  # Retrieve script arguments
  targetDir=$1
  create_symlinks=$2
  only_python_version=$3

  # Add trap for clean
  trap clean EXIT

  # Install
  OLD_PYTHONPATH=$PYTHONPATH

  if [ -z "$only_python_version" ]; then
    # Try to install all
    install_for_py2
    install_for_py3
  elif [ "$only_python_version" == "python2" ]; then
    # Install only python 2 version
    install_for_py2
  elif [ "$only_python_version" == "python3" ]; then
    # Install only python 3 version
    install_for_py3
  fi

  # Normal exit
  exit 0
